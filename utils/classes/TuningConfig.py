from enum import Enum
from dataclasses import dataclass


class JobCollectionType(Enum):
    """The type of jobs in a collection. These include static and dynamic tuning intervals, as well as special and optimum runs."""

    STATIC = 0
    DYNAMIC = 1
    SPECIAL = 2
    OPTIMUM = 3
    STATIC_MPI = 4

    @staticmethod
    def from_str(label):
        match label.lower():
            case "static":
                return JobCollectionType.STATIC
            case "dynamic":
                return JobCollectionType.DYNAMIC
            case "special":
                return JobCollectionType.SPECIAL
            case "optimum":
                return JobCollectionType.OPTIMUM
            case "static_mpi":
                return JobCollectionType.STATIC_MPI
            case _:
                raise NotImplementedError


class FunctorType(Enum):
    LJ_FUNCTOR_AVX = 0

    @staticmethod
    def from_str(label):
        if label.lower() in ("ljfunctoravx"):
            return FunctorType.LJ_FUNCTOR_AVX
        else:
            print(f"Functor {label} not implemented")
            raise NotImplementedError


class ContainerType(Enum):
    LINKED_CELLS = 0
    VERLET_CLUSTER_LISTS = 1
    VERLET_LISTS = 2
    VERLET_LISTS_CELLS = 3
    PARIWISE_VERLET_LISTS = 4
    VAR_VERLET_LISTS_AS_BUILD = 5

    @staticmethod
    def from_str(label):
        match label.lower():
            case "linkedcells":
                return ContainerType.LINKED_CELLS
            case "verletclusterlists":
                return ContainerType.VERLET_CLUSTER_LISTS
            case "verletlists":
                return ContainerType.VERLET_LISTS
            case "verletlistscells":
                return ContainerType.VERLET_LISTS_CELLS
            case "pairwiseverletlists":
                return ContainerType.PARIWISE_VERLET_LISTS
            case "varverletlistsasbuild":
                return ContainerType.VAR_VERLET_LISTS_AS_BUILD
            case _:
                print(f"Container {label} not implemented")
                raise NotImplementedError

    def __str__(self):
        match self:
            case ContainerType.LINKED_CELLS:
                return "LC"
            case ContainerType.VERLET_CLUSTER_LISTS:
                return "VCL"
            case ContainerType.VERLET_LISTS:
                return "VL"
            case ContainerType.VERLET_LISTS_CELLS:
                return "VLC"
            case ContainerType.PARIWISE_VERLET_LISTS:
                return "VLP"
            case ContainerType.VAR_VERLET_LISTS_AS_BUILD:
                return "VVL"
            case _:
                return ""

class DataLayoutType(Enum):
    AOS = 0
    SOA = 1

    @staticmethod
    def from_str(label):
        match label.lower():
            case "aos":
                return DataLayoutType.AOS
            case "soa":
                return DataLayoutType.SOA
            case _:
                raise NotImplementedError

    def __str__(self):
        match self:
            case DataLayoutType.AOS:
                return "AoS"
            case DataLayoutType.SOA:
                return "SoA"
            case _:
                return ""


@dataclass
class TuningConfig:
    """Represents the configuration of a specific iteration as generated by the iteration logger."""

    functor: FunctorType
    interaction_type: str
    container: ContainerType
    cellsize_factor: float
    traversal: str
    data_layout: DataLayoutType
    newton3: bool
    tuning: bool

    @staticmethod
    def from_strs(functor, interaction, container, csf, traversal, layout, n3, tuning):
        # shorten traversal strings
        traversal = traversal.upper()
        traversal = traversal.replace("COMBINED", "COMB")
        traversal = traversal.replace("LIST_ITERATION", "LITER")
        traversal = traversal.replace("AS_BUILT", "BUILT")
        traversal = traversal.replace("BALANCED", "BAL")
        traversal = traversal.replace("_SOA", "")
        
        
        return TuningConfig(
            FunctorType.from_str(functor),
            interaction,
            ContainerType.from_str(container),
            float(csf),
            traversal,
            DataLayoutType.from_str(layout),
            n3.lower() in ["enabled"],
            tuning.lower() in ["true"],
        )

    def was_tuning(self):
        return self.tuning

    def __str__(self):
        # remove prefix to avoid duplication
        trav = self.traversal
        if trav.startswith(str(self.container)):
            trav = trav[len(str(self.container)) + 1 :]
        return f"{self.container}-{trav.upper()}-{'NoN3L' if not self.newton3 else 'N3L'}-{self.data_layout}-CSF{int(self.cellsize_factor) if self.cellsize_factor.is_integer() else self.cellsize_factor}"

    def __eq__(self, other):
        return str(self) == str(other)
