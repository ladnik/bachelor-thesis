\chapter[AutoPas]{AutoPas}
\label{cp:autopas}

{
	\parindent0pt
	This chapter examines the particle simulation library AutoPas and provides an overview of its architecture and features. In \autoref{sec:background}, the concept of autotuning is introduced, together with the \texttt{md-flexible} application.
	The various algorithmic configuration parameters available  are introduced thereafter in \autoref{sec:config_params}. Additionally, \autoref{sec:tuning_strategies} shortly outlines the different tuning strategies for the selection of the optimal combination of these parameters.

	The contents of this chapter are mainly drawn from the works introducing AutoPas, specifically the publications by Gratl et al. \cite{Gratl2019, Gratl2021, GratlGassner2025} and Seckler et al. \cite{Seckler2021}, as well as the AutoPas documentation \cite{AutoPas2025}.
}


\section{Background}
\label{sec:background}
AutoPas is an open-source \CC{} library that facilitates short-range MD simulations. The feature that sets AutoPas apart from other particle simulation software such as ls1-mardyn\footnote{\href{https://www.ls1-mardyn.de/}{\texttt{https://www.ls1-mardyn.de/}}}, LAMMPS\footnote{\href{https://www.lammps.org/}{\texttt{https://www.lammps.org/}}}, or GROMACS\footnote{\href{https://www.gromacs.org/}{\texttt{https://www.gromacs.org/}}}, is the autotuning algorithm.

The mentioned simulation programs are highly specialized on specific applications and therefore focus on optimizing the algorithms used in these environments.
In contrast, AutoPas aims to provide optimal simulation conditions across a wider range of scenarios by implementing a broad set of algorithms and dynamically switching between them at runtime.
This removes the need for expert knowledge in simulation setup and allows for a simple interface by which the AutoPas library can be viewed as a black-box.

As referred to earlier, this autotuning approach is currently implemented as follows: In each iteration that is a multiple of a predefined \texttt{tuning-interval}, a tuning phase is initiated. In these tuning phases, a number of configurations are selected to be sampled; these configurations each represent a distinct combination of algorithmic settings (c.f. \autoref{sec:config_params}). All configurations are sampled, i.e., executed for a set number of iterations, after which the measurements are condensed into a single value, referred to as \enquote{evidence.} This evidence is used to rank the sampled configurations based on a tuning metric, either runtime or energy consumption. The best configuration is selected to compute the subsequent iterations until the beginning of the next tuning phase.


As AutoPas is only a library, we require an application that interacts with it and provides a front end to allow for our particle simulations. In this work, we will use the \texttt{md-flexible} application, provided together with AutoPas. Based on the 12-6 LJ potential and Störmer-Verlet time integration, \texttt{md-flexible} facilitates MD simulations with integrated parallelization, distributed memory computation, load balancing, and highly configurable scenario generators.


\section{Configuration Parameters}
\label{sec:config_params}

As outlined in \autoref{sec:background}, AutoPas is designed to allow for dynamic adaptation of the algorithmic configuration used in computing the actual simulation steps. The relevant parameters are categorized and described in the following.

\subsection{Containers}

Containers in AutoPas are classes responsible for particle management and neighbor identification. They store the actual particle data in a specific memory layout and allow for the efficient lookup of neighbors, i.e. particles inside the cutoff radius $r_c$. Grouped by neighbor identification algorithm, there are currently four different types of containers.

\begin{description}[leftmargin=!,labelwidth=\widthof{\textbf{Verlet Cluster Lists}}]
	\item[\textbf{Direct Sum}] The simplest algorithm is Direct Sum: It calculates the distances between the current particle and all other particles, discards those which lie outside of $r_c$, and proceeds with the force calculations on the remaining particles. As this method has complexity $\mathcal{O}\left(n^2\right)$, it is only suitable for small scenarios.
	\item[\textbf{Linked Cells}] The Linked Cell approach divides the simulation space up into cells along a regular grid. Each particle is then assigned to the cell corresponding to its location in space. Considering a cell size greater or equal to $r_c$, only neighboring cells have to be considered in the force calculations. For homogeneous particle distributions, this reduces the complexity to $\mathcal{O}\left(n\right)$. Additionally, particles close to each other in simulation space are close in memory, which results in cache-friendly behavior and allows for vectorization.
	\item[\textbf{Verlet Lists}] One drawback of the Linked Cells algorithm is the high number of particles that lie inside neighboring cells, but outside the cutoff radius. They are discarded in the force computation, but still require distance computations. The Verlet List algorithm solves this issue by introducing a neighbor list of interaction partners for each particle. As rebuilding these lists is expensive, not only neighbors inside the cutoff radius are stored, but also particles that might move into interaction range. This is achieved by extending the radius by a so-called Verlet skin. As particles move, these neighbor lists have to be rebuilt periodically, relying on other neighbor identification algorithms such as Linked Cells. Furthermore, Verlet Lists have a large memory footprint (one list per particle) and do not provide the advantageous memory properties of Linked Cells.
	\item[\textbf{Verlet Cluster Lists}] To reduce the overall number of lists in the Verlet List approach, multiple particles can be clustered together, effectively combining their individual neighbor lists to a single one for the whole cluster. This is possible due to the fact that neighboring particles are likely to share multiple of their neighbors. The clustering is based on a subdivision of the simulation domain into a Cartesian grid ($x/y$) which, extruded along the third dimension ($z$), forms several towers. Inside each of these towers, particles are grouped into clusters of size $M$, ordered by their position along the $z$-axis. Instead of an exact combination of all cutoff radii, a simple bounding box is constructed around each cluster. Thus, Verlet Cluster Lists not only reduce the total number of neighbor lists, but also allow for vectorization, as clusters are groupings of spatially close particles. On the other hand, the number of particles for which distance calculations have to be performed increases.
\end{description}

\begin{figure}
	\centering
	\def\sz{2.25em}
	\def\rc{2.25em}
	\def\psz{0.4em}
	\tikzset{
		mgrid/.style = {matrix of nodes, ampersand replacement=\&, nodes={draw, minimum width=\sz, minimum height=\sz, anchor=center}, column sep=-\pgflinewidth, row sep=-\pgflinewidth},
		particle/.style={draw=black, circle, minimum size=\psz, inner sep=0pt, outer sep = 0pt},
		particleOutside/.style={particle, fill=violet, pattern={Lines[angle=45,distance=1pt]}},
		particleInside/.style={particle, fill=green, pattern={Lines[angle=45,distance=1pt]}},
		checked/.style={draw=none, fill=blueverylight, inner sep=0pt},
		checkedborder/.style={draw=none, inner sep = 0pt},
		cutoff/.style={draw=bluedarkoutline, circle, thick, dotted, minimum size=2*\rc, inner sep=0pt, outer sep=0pt},
		skin/.style={accentRed, circle, thick, dotted, minimum size=2.6*\rc, inner sep=0pt, outer sep=0pt},
		arrow/.style={-latex},
		extra/.style={dashed},
	}
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}
			\draw[step=\sz] (0,0) grid (4*\sz,4*\sz);


			\begin{scope}[shift={(-1*\sz,-1*\sz)}]
				\node[particle, fill=lightred] (pact) at (2.5*\sz,2.5*\sz) {};
				\node[fill=black, circle, minimum size=1pt, inner sep=0pt, outer sep=0pt] at (pact) {};
				\node[cutoff] (cr) at (pact) {};
				\node[color=bluedarkoutline, anchor=north] at ([shift={(0,-\rc)}]cr) {$r_c$};

				\node[particleOutside]        (p1)  at (1.5*\sz+0.3em,4.5*\sz-0.3em) {};
				\node[particleOutside]        (p2)  at (4.5*\sz-0.6em,2.5*\sz-0.4em) {};
				\node[particleOutside]        (p3)  at (2.5*\sz-0.3em,4.5*\sz+0.6em) {};
				\node[particleInside]  (p4)  at (2.5*\sz+0.1em,1.5*\sz+0.4em) {};
				\node[particleOutside]        (p5)  at (4.5*\sz-0.7em,1.5*\sz-0.8em) {};
				\node[particleOutside]        (p6)  at (4.5*\sz-0.3em,4.5*\sz-0.4em) {};
				\node[particleOutside] (p7)  at (3.5*\sz-0.7em,3.5*\sz+0.6em) {};
				\node[particleInside]  (p8)  at (1.5*\sz+0.6em,2.5*\sz-0.67em) {};
				\node[particleOutside]        (p9)  at (4.5*\sz-0.2em,3.5*\sz+0.3em) {};
				\node[particleOutside]        (p10) at (4.5*\sz+0.7em,1.5*\sz-0.7em) {};
				\node[particleOutside] (p11) at (1.5*\sz+0.5em,3.5*\sz+0.4em) {};
				\node[particleOutside]        (p12) at (4.5*\sz-0.4em,1.5*\sz+0.7em) {};
				\node[particleOutside]        (p13) at (3.5*\sz+0.7em,4.5*\sz-0.1em) {};
				\node[particleOutside]        (p14) at (4.5*\sz+0.4em,2.5*\sz-0.2em) {};
				\node[particleOutside] (p15) at (1.5*\sz+0.2em,1.5*\sz-0.5em) {};
				\node[particleInside]  (p16) at (2.5*\sz+0.4em,3.5*\sz-0.5em) {};
				\node[particleOutside] (p17) at (1.5*\sz-0.3em,2.5*\sz+0.5em) {};
				\node[particleOutside] (p18) at (3.5*\sz+0.7em,1.5*\sz+0.2em) {};
				\node[particleInside]  (p19) at (3.5*\sz-0.5em,2.5*\sz+0.7em) {};
				\node[particleOutside] (p20) at (3.5*\sz-0.4em,1.5*\sz-0.7em) {};
			\end{scope}

			\draw[arrow, extra] (pact) -- (p1);
			\draw[arrow, extra] (pact) -- (p2);
			\draw[arrow, extra] (pact) -- (p3);
			\draw[arrow] (pact) -- (p4);
			\draw[arrow, extra] (pact) -- (p5);
			\draw[arrow, extra] (pact) -- (p6);
			\draw[arrow, extra] (pact) -- (p7);
			\draw[arrow] (pact) -- (p8);
			\draw[arrow, extra] (pact) -- (p9);
			\draw[arrow, extra] (pact) -- (p10);
			\draw[arrow, extra] (pact) -- (p11);
			\draw[arrow, extra] (pact) -- (p12);
			\draw[arrow, extra] (pact) -- (p13);
			\draw[arrow, extra] (pact) -- (p14);
			\draw[arrow, extra] (pact) -- (p15);
			\draw[arrow] (pact) -- (p16);
			\draw[arrow, extra] (pact) -- (p17);
			\draw[arrow, extra] (pact) -- (p18);
			\draw[arrow] (pact) -- (p19);
			\draw[arrow, extra] (pact) -- (p20);
		\end{tikzpicture}
		\subcaption{Direct Sum}
	\end{subfigure}%
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}
			\draw[step=\sz] (0,0) grid (4*\sz,4*\sz);


			\begin{scope}[on background layer]
				\node[checked, fit={(0,0) (3*\sz,3*\sz)}] {};
			\end{scope}

			\node[checkedborder, fit={(0,0) (3*\sz,3*\sz)}] {};


			\begin{scope}[shift={(-1*\sz,-1*\sz)}]
				\node[particle, fill=lightred] (pact) at (2.5*\sz,2.5*\sz) {};
				\node[fill=black, circle, minimum size=1pt, inner sep=0pt, outer sep=0pt] at (pact) {};
				\node[cutoff] (cr) at (pact) {};
				\node[color=bluedarkoutline] at ([shift={(0.9*\rc,0.9*\rc)}]cr) {$r_c$};

				\node[particle]        (p1)  at (1.5*\sz+0.3em,4.5*\sz-0.3em) {};
				\node[particle]        (p2)  at (4.5*\sz-0.6em,2.5*\sz-0.4em) {};
				\node[particle]        (p3)  at (2.5*\sz-0.3em,4.5*\sz+0.6em) {};
				\node[particleInside]  (p4)  at (2.5*\sz+0.1em,1.5*\sz+0.4em) {};
				\node[particle]        (p5)  at (4.5*\sz-0.7em,1.5*\sz-0.8em) {};
				\node[particle]        (p6)  at (4.5*\sz-0.3em,4.5*\sz-0.4em) {};
				\node[particleOutside] (p7)  at (3.5*\sz-0.7em,3.5*\sz+0.6em) {};
				\node[particleInside]  (p8)  at (1.5*\sz+0.6em,2.5*\sz-0.67em) {};
				\node[particle]        (p9)  at (4.5*\sz-0.2em,3.5*\sz+0.3em) {};
				\node[particle]        (p10) at (4.5*\sz+0.7em,1.5*\sz-0.7em) {};
				\node[particleOutside] (p11) at (1.5*\sz+0.5em,3.5*\sz+0.4em) {};
				\node[particle]        (p12) at (4.5*\sz-0.4em,1.5*\sz+0.7em) {};
				\node[particle]        (p13) at (3.5*\sz+0.7em,4.5*\sz-0.1em) {};
				\node[particle]        (p14) at (4.5*\sz+0.4em,2.5*\sz-0.2em) {};
				\node[particleOutside] (p15) at (1.5*\sz+0.2em,1.5*\sz-0.5em) {};
				\node[particleInside]  (p16) at (2.5*\sz+0.4em,3.5*\sz-0.5em) {};
				\node[particleOutside] (p17) at (1.5*\sz-0.3em,2.5*\sz+0.5em) {};
				\node[particleOutside] (p18) at (3.5*\sz+0.7em,1.5*\sz+0.2em) {};
				\node[particleInside]  (p19) at (3.5*\sz-0.5em,2.5*\sz+0.7em) {};
				\node[particleOutside] (p20) at (3.5*\sz-0.4em,1.5*\sz-0.7em) {};
			\end{scope}

			\draw[arrow, extra] (pact) -- (p11);
			\draw[arrow] (pact) -- (p16);
			\draw[arrow, extra] (pact) -- (p7);
			\draw[arrow] (pact) -- (p8);
			\draw[arrow, extra] (pact) -- (p17);
			\draw[arrow] (pact) -- (p19);
			\draw[arrow, extra] (pact) -- (p15);
			\draw[arrow] (pact) -- (p4);
			\draw[arrow, extra] (pact) -- (p18);
			\draw[arrow, extra] (pact) -- (p20);
		\end{tikzpicture}
		\subcaption{Linked Cells}
	\end{subfigure}%
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}
			\draw[step=\sz] (0,0) grid (4*\sz,4*\sz);


			\begin{scope}[shift={(-1*\sz,-1*\sz)}]
				\node[particle, fill=lightred] (pact) at (2.5*\sz,2.5*\sz) {};
				\node[fill=black, circle, minimum size=1pt, inner sep=0pt, outer sep=0pt] at (pact) {};
				\node[cutoff] (cr) at (pact) {};
				\node[color=bluedarkoutline, anchor=north] at ([shift={(-0.2*\sz,\rc)}]cr) {$r_c$};
				\node[skin] (sk) at (pact) {};
				\node[color=reddark] at ([shift={(1.15*\rc,1.15*\rc)}]sk) {$r_s$};

				\node[particle]        (p1)  at (1.5*\sz+0.3em,4.5*\sz-0.3em) {};
				\node[particle]        (p2)  at (4.5*\sz-0.6em,2.5*\sz-0.4em) {};
				\node[particle]        (p3)  at (2.5*\sz-0.3em,4.5*\sz+0.6em) {};
				\node[particleInside]  (p4)  at (2.5*\sz+0.1em,1.5*\sz+0.4em) {};
				\node[particle]        (p5)  at (4.5*\sz-0.7em,1.5*\sz-0.8em) {};
				\node[particle]        (p6)  at (4.5*\sz-0.3em,4.5*\sz-0.4em) {};
				\node[particle] (p7)  at (3.5*\sz-0.7em,3.5*\sz+0.6em) {};
				\node[particleInside]  (p8)  at (1.5*\sz+0.6em,2.5*\sz-0.67em) {};
				\node[particle]        (p9)  at (4.5*\sz-0.2em,3.5*\sz+0.3em) {};
				\node[particle]        (p10) at (4.5*\sz+0.7em,1.5*\sz-0.7em) {};
				\node[particle] (p11) at (1.5*\sz+0.5em,3.5*\sz+0.4em) {};
				\node[particle]        (p12) at (4.5*\sz-0.4em,1.5*\sz+0.7em) {};
				\node[particle]        (p13) at (3.5*\sz+0.7em,4.5*\sz-0.1em) {};
				\node[particle]        (p14) at (4.5*\sz+0.4em,2.5*\sz-0.2em) {};
				\node[particle] (p15) at (1.5*\sz+0.2em,1.5*\sz-0.5em) {};
				\node[particleInside]  (p16) at (2.5*\sz+0.4em,3.5*\sz-0.5em) {};
				\node[particleOutside] (p17) at (1.5*\sz-0.3em,2.5*\sz+0.5em) {};
				\node[particle] (p18) at (3.5*\sz+0.7em,1.5*\sz+0.2em) {};
				\node[particleInside]  (p19) at (3.5*\sz-0.5em,2.5*\sz+0.7em) {};
				\node[particle] (p20) at (3.5*\sz-0.4em,1.5*\sz-0.7em) {};
			\end{scope}

			\draw[arrow] (pact) -- (p16);
			\draw[arrow] (pact) -- (p8);
			\draw[arrow, extra] (pact) -- (p17);
			\draw[arrow] (pact) -- (p19);
			\draw[arrow] (pact) -- (p4);
		\end{tikzpicture}
		\subcaption{Verlet Lists}
	\end{subfigure}%
	\caption{An illustration of selected neighbor identification algorithms used for containers in AutoPas. Particles for which distance calculations are performed are marked with a diagonal line pattern, dashed arrows lead to particles outside the cutoff radius. This figure is based on Gratl et al. \cite{Gratl2021}.}
	\label{fig:containers}
\end{figure}

\subsection{Traversals}
\label{sec:traversals}
Containers provide an efficient way to identify neighbors of a particle --- to efficiently compute the interactions themselves however, the traversal, i.e. the order in which particles are iterated over, is also important. Traversals are relevant for the performance mostly due to memory and cache access patterns. Different container types require traversals, tailored to the data structures used in storing the neighbors. A limited selection of these traversals will be explained hereafter.


\begin{description}[leftmargin=!,labelwidth=\widthof{\textbf{VL List Iteration}}]
	\item[\textbf{C01 Base Step}] The c01 base step is not a traversal strategy on its own, but defines the cells in which interaction computations must be performed for any given particle. It is implemented for the Linked Cells and Verlet List Cells containers as \texttt{lc\_c01} and \texttt{vlc\_c01} respectively. As the simplest base step, it computes all interactions with the neighboring cells of the particle’s base cell.
	\item[\textbf{C18 Base Step}] Similarly, c18 computes interactions only on its forward neighbors, potentially halving the number of calculations that have to be performed. This base step is enabled by Newton's third law (cf. \autoref{sec:newton}), where only one of the interacting particles needs to compute the interaction force. However, some form of synchronization must be employed, as to avoid race conditions on force updates. This limits the extent to which parallelization is possible.
	\item[\textbf{VL List Iteration}] The VL List Iteration is the only traversal strategy available for Verlet Lists. All lists are processed in parallel, within a given list the particles are traversed in sequential order.
\end{description}

\subsection{Additional Parameters}
Moreover, there are a number of additional configuration parameters that do not fall into the aforementioned groups. They are given below.

\begin{description}[leftmargin=!,labelwidth=\widthof{\textbf{Cell Size Factor}}]
	\item[\textbf{Data Layout}] The data layout option concerns the layout of the particle structures in memory. As each particle has multiple attributes associated to it, all particles together can be laid out either as an Array of Structures (AoS) or a Structure of Arrays (SoA). In the AoS layout, all particles are stored after each other; in the SoA layout, each attribute type is stored in a separate array, with each entry holding the value for a specific particle. \autoref{fig:aos_soa} illustrates both principles.
	\item[\textbf{Newton3}] As mentioned in \autoref{sec:newton}, Newton's third law states that $F_a = -F_b$ for two bodies $a, b$ exerting forces on each other. This allows for optimizing pairwise interactions, as only one force has to be computed. However, this approach is not always beneficial as it may limit parallelization --- once the force is evaluated, both particles must be updated at once.
	\item[\textbf{Cell Size Factor}] The cell size factor (CSF) parameter specifies the side length of the cells in relation to the interaction cutoff radius $r_c$. It can reduce the number of particles for which distances have to be calculated, as a smaller cell side length better approximates the spherical nature of the cutoff radius. This behavior is illustrated in  \autoref{fig:lc_csf}.
\end{description}

\begin{figure}[htpb]
	% TODO: color scheme
	\centering
	\begin{tikzpicture}
		\def\sz{2em}
		\def\pad{0.125em}
		\def\brpad{3.25ex}
		\def\lblspc{2em}
		\def\rowspc{8ex}
		\tikzset{
			lbl/.style={draw=none, minimum width=\sz, minimum height=\sz, text depth=1pt},
			attr/.style={draw, minimum width=\sz, minimum height=\sz, anchor=west, text depth=1pt},
			br/.style={decorate,decoration={brace, amplitude=1ex, raise=0.5ex}},
			p1/.style={draw=black, fill=lightblue},
			p2/.style={draw=black, fill=lightviolet},
			p3/.style={draw=black, fill=lightred},
		}
		
		\node[lbl] (aos) {\textbf{AoS}};
		
		\node[attr, p1, right=\lblspc of aos] (x1) {$r_x^{(1)}$};
		\node[attr, p1, right=-\pgflinewidth of x1] (y1) {$r_y^{(1)}$};
		\node[attr, p1, right=-\pgflinewidth of y1] (z1) {$r_z^{(1)}$};
		\node[attr, p1, right=-\pgflinewidth of z1] (a1) {\textellipsis};
		\draw [br] ([xshift=\pad]x1.north west) -- ([xshift=-\pad]a1.north east) node[midway, yshift=\brpad]{Particle 1};
		
		\node[attr, p2, right=-\pgflinewidth of a1] (x2) {$r_x^{(2)}$};
		\node[attr, p2, right=-\pgflinewidth of x2] (y2) {$r_y^{(2)}$};
		\node[attr, p2, right=-\pgflinewidth of y2] (z2) {$r_z^{(2)}$};
		\node[attr, p2, right=-\pgflinewidth of z2] (a2) {\textellipsis};
		\draw [br] ([xshift=\pad]x2.north west) -- ([xshift=-\pad]a2.north east) node[midway, yshift=\brpad]{Particle 2};
		
		\node[attr, p3, right=-\pgflinewidth of a2] (x3) {$r_x^{(3)}$};
		\node[attr, p3, right=-\pgflinewidth of x3] (y3) {$r_y^{(3)}$};
		\node[attr, p3, right=-\pgflinewidth of y3] (z3) {$r_z^{(3)}$};
		\node[attr, p3, right=-\pgflinewidth of z3] (a3) {\textellipsis};
		\draw [br] ([xshift=\pad]x3.north west) -- ([xshift=-\pad]a3.north east) node[midway, yshift=\brpad]{Particle 3};
		\node[attr,right=-\pgflinewidth of a3] {\textellipsis};
		
		\node[lbl, below=\rowspc of aos] (soa) {\textbf{SoA}};
		
		\node[attr, p1, right=\lblspc of soa] (x1d) {$r_x^{(1)}$};
		\node[attr, p2, right=-\pgflinewidth of x1d] (x2d) {$r_x^{(2)}$};
		\node[attr, p3, right=-\pgflinewidth of x2d] (x3d) {$r_x^{(3)}$};
		\node[attr, right=-\pgflinewidth of x3d] (a1d) {\textellipsis};
		\draw [br] ([xshift=\pad]x1d.north west) -- ([xshift=-\pad]a1d.north east) node[midway, yshift=\brpad]{$r_x^{(i)}$};
		
		\node[attr, p1, right=-\pgflinewidth of a1d] (y1d) {$r_y^{(1)}$};
		\node[attr, p2, right=-\pgflinewidth of y1d] (y2d) {$r_y^{(2)}$};
		\node[attr, p3, right=-\pgflinewidth of y2d] (y3d) {$r_y^{(3)}$};
		\node[attr, right=-\pgflinewidth of y3d] (a2d) {\textellipsis};
		\draw [br] ([xshift=\pad]y1d.north west) -- ([xshift=-\pad]a2d.north east) node[midway, yshift=\brpad]{$r_y^{(i)}$};
		
		\node[attr, p1, right=-\pgflinewidth of a2d] (z1d) {$r_z^{(1)}$};
		\node[attr, p2, right=-\pgflinewidth of z1d] (z2d) {$r_z^{(2)}$};
		\node[attr, p3, right=-\pgflinewidth of z2d] (z3d) {$r_z^{(3)}$};
		\node[attr, right=-\pgflinewidth of z3d] (a3d) {\textellipsis};
		\draw [br] ([xshift=\pad]z1d.north west) -- ([xshift=-\pad]a3d.north east) node[midway, yshift=\brpad]{$r_z^{(i)}$};
		\node[attr,right=-\pgflinewidth of a3d] {\textellipsis};
		
	\end{tikzpicture}
	\caption{Comparison between the Array of Structures (AoS) and Structure of Arrays (SoA) memory layouts. The $r^{(i)}$s correspond to the position vector of the $i$th particle.}
	\label{fig:aos_soa}
\end{figure}

\begin{figure}
	\centering
	\def\sz{2.25em}
	\def\rc{2.25em}
	\def\psz{0.4em}
	\tikzset{
		mgrid/.style = {matrix of nodes, ampersand replacement=\&, nodes={draw, minimum width=\sz, minimum height=\sz, anchor=center}, column sep=-\pgflinewidth, row sep=-\pgflinewidth},
		particle/.style={draw=black, circle, minimum size=\psz, inner sep=0pt, outer sep = 0pt},
		particleOutside/.style={particle, fill=violet, pattern={Lines[angle=45,distance=1pt]}},
		particleInside/.style={particle, fill=green, pattern={Lines[angle=45,distance=1pt]}},
		checked/.style={draw=none, fill=blueverylight, inner sep=0pt},
		checkedborder/.style={draw=none, inner sep = 0pt},
		cutoff/.style={draw=bluedarkoutline, circle, thick, dotted, minimum size=2*\rc, inner sep=0pt, outer sep=0pt},
		arrow/.style={-latex},
		extra/.style={dashed},
	}
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}
			\draw[step=\sz] (0,0) grid (4*\sz,4*\sz);


			\begin{scope}[on background layer]
				\node[checked, fit={(0,0) (3*\sz,3*\sz)}] {};
			\end{scope}

			\node[checkedborder, fit={(0,0) (3*\sz,3*\sz)}] {};


			\begin{scope}[shift={(-1*\sz,-1*\sz)}]
				\node[particle, fill=lightred] (pact) at (2.5*\sz,2.5*\sz) {};
				\node[fill=black, circle, minimum size=1pt, inner sep=0pt, outer sep=0pt] at (pact) {};
				\node[cutoff] (cr) at (pact) {};
				\node[color=bluedarkoutline] at ([shift={(0.9*\rc,0.9*\rc)}]cr) {$r_c$};

				\node[particle]        (p1)  at (1.5*\sz+0.3em,4.5*\sz-0.3em) {};
				\node[particle]        (p2)  at (4.5*\sz-0.6em,2.5*\sz-0.4em) {};
				\node[particle]        (p3)  at (2.5*\sz-0.3em,4.5*\sz+0.6em) {};
				\node[particleInside]  (p4)  at (2.5*\sz+0.1em,1.5*\sz+0.4em) {};
				\node[particle]        (p5)  at (4.5*\sz-0.7em,1.5*\sz-0.8em) {};
				\node[particle]        (p6)  at (4.5*\sz-0.3em,4.5*\sz-0.4em) {};
				\node[particleOutside] (p7)  at (3.5*\sz-0.7em,3.5*\sz+0.6em) {};
				\node[particleInside]  (p8)  at (1.5*\sz+0.6em,2.5*\sz-0.67em) {};
				\node[particle]        (p9)  at (4.5*\sz-0.2em,3.5*\sz+0.3em) {};
				\node[particle]        (p10) at (4.5*\sz+0.7em,1.5*\sz-0.7em) {};
				\node[particleOutside] (p11) at (1.5*\sz+0.5em,3.5*\sz+0.4em) {};
				\node[particle]        (p12) at (4.5*\sz-0.4em,1.5*\sz+0.7em) {};
				\node[particle]        (p13) at (3.5*\sz+0.7em,4.5*\sz-0.1em) {};
				\node[particle]        (p14) at (4.5*\sz+0.4em,2.5*\sz-0.2em) {};
				\node[particleOutside] (p15) at (1.5*\sz+0.2em,1.5*\sz-0.5em) {};
				\node[particleInside]  (p16) at (2.5*\sz+0.4em,3.5*\sz-0.5em) {};
				\node[particleOutside] (p17) at (1.5*\sz-0.3em,2.5*\sz+0.5em) {};
				\node[particleOutside] (p18) at (3.5*\sz+0.7em,1.5*\sz+0.2em) {};
				\node[particleInside]  (p19) at (3.5*\sz-0.5em,2.5*\sz+0.7em) {};
				\node[particleOutside] (p20) at (3.5*\sz-0.4em,1.5*\sz-0.7em) {};
			\end{scope}

			\draw[arrow, extra] (pact) -- (p11);
			\draw[arrow] (pact) -- (p16);
			\draw[arrow, extra] (pact) -- (p7);
			\draw[arrow] (pact) -- (p8);
			\draw[arrow, extra] (pact) -- (p17);
			\draw[arrow] (pact) -- (p19);
			\draw[arrow, extra] (pact) -- (p15);
			\draw[arrow] (pact) -- (p4);
			\draw[arrow, extra] (pact) -- (p18);
			\draw[arrow, extra] (pact) -- (p20);
		\end{tikzpicture}
		\subcaption{Cell Size Factor \num{1.0}}
	\end{subfigure}%
	\begin{subfigure}{0.3\textwidth}
		\centering
		\begin{tikzpicture}
			\def\csf{0.5}
			\draw[step=\csf*\sz, black!30, thin] (0,0) grid (4*\sz,4*\sz);
			\draw[step=\sz] (0,0) grid (4*\sz,4*\sz);


			\begin{scope}[on background layer]
				\node[checked, fit={(\csf*\sz,\csf*\sz) (5*\csf*\sz,5*\csf*\sz)}] {};
			\end{scope}

			\node[checkedborder, fit={(\csf*\sz,\csf*\sz) (5*\csf*\sz,5*\csf*\sz)}] {};


			\begin{scope}[shift={(-1*\sz,-1*\sz)}]
				\node[particle, fill=lightred] (pact) at (2.5*\sz,2.5*\sz) {};
				\node[fill=black, circle, minimum size=1pt, inner sep=0pt, outer sep=0pt] at (pact) {};
				\node[cutoff] (cr) at (pact) {};
				\node[color=bluedarkoutline] at ([shift={(0.9*\rc,0.9*\rc)}]cr) {$r_c$};

				\node[particle]        (p1)  at (1.5*\sz+0.3em,4.5*\sz-0.3em) {};
				\node[particle]        (p2)  at (4.5*\sz-0.6em,2.5*\sz-0.4em) {};
				\node[particle]        (p3)  at (2.5*\sz-0.3em,4.5*\sz+0.6em) {};
				\node[particleInside]  (p4)  at (2.5*\sz+0.1em,1.5*\sz+0.4em) {};
				\node[particle]        (p5)  at (4.5*\sz-0.7em,1.5*\sz-0.8em) {};
				\node[particle]        (p6)  at (4.5*\sz-0.3em,4.5*\sz-0.4em) {};
				\node[particle] (p7)  at (3.5*\sz-0.7em,3.5*\sz+0.6em) {};
				\node[particleInside]  (p8)  at (1.5*\sz+0.6em,2.5*\sz-0.67em) {};
				\node[particle]        (p9)  at (4.5*\sz-0.2em,3.5*\sz+0.3em) {};
				\node[particle]        (p10) at (4.5*\sz+0.7em,1.5*\sz-0.7em) {};
				\node[particle] (p11) at (1.5*\sz+0.5em,3.5*\sz+0.4em) {};
				\node[particle]        (p12) at (4.5*\sz-0.4em,1.5*\sz+0.7em) {};
				\node[particle]        (p13) at (3.5*\sz+0.7em,4.5*\sz-0.1em) {};
				\node[particle]        (p14) at (4.5*\sz+0.4em,2.5*\sz-0.2em) {};
				\node[particle] (p15) at (1.5*\sz+0.2em,1.5*\sz-0.5em) {};
				\node[particleInside]  (p16) at (2.5*\sz+0.4em,3.5*\sz-0.5em) {};
				\node[particle] (p17) at (1.5*\sz-0.3em,2.5*\sz+0.5em) {};
				\node[particle] (p18) at (3.5*\sz+0.7em,1.5*\sz+0.2em) {};
				\node[particleInside]  (p19) at (3.5*\sz-0.5em,2.5*\sz+0.7em) {};
				\node[particle] (p20) at (3.5*\sz-0.4em,1.5*\sz-0.7em) {};
			\end{scope}

			\draw[arrow] (pact) -- (p16);
			\draw[arrow] (pact) -- (p8);
			\draw[arrow] (pact) -- (p19);
			\draw[arrow] (pact) -- (p4);
		\end{tikzpicture}
		\subcaption{Cell Size Factor \num{0.5}}
	\end{subfigure}
	\caption{Impact of the cell size factor on the number of distance calculations. The dotted line represents the cutoff radius, superfluous distance calculations are marked by dashed arrows.}
	\label{fig:lc_csf}
\end{figure}



\section{Tuning Strategies}
\label{sec:tuning_strategies}
% keep this rather short

AutoPas provides a variety of different tuning strategies. These are used in sampling and selecting the new optimal configuration in the tuning phases of the autotuner. As they are not particularly relevant to the topics discussed in this thesis, only selected strategies are presented.
\begin{description}[leftmargin=!,labelwidth=\widthof{\textbf{PredictiveTuning }}]
	\item[\textbf{FullSearch}] The default tuning strategy is an exhaustive search over all possible configurations, i.e., all combinations of parameters. The optimal configuration is thereby guaranteed to be trialed at some point. However, the space of all possible configurations grows exponentially in the number of parameters, of which many configurations may be highly suboptimal. Other tuning strategies are therefore more suitable for most scenarios.
	\item[\textbf{RandomSearch}] The random search tuning strategy randomly selects a given number of configurations which are then sampled. This can greatly reduce the number of configurations to test, but may not select the optimal configuration.
	\item[\textbf{PredictiveTuning}] The predictive tuning strategy reduces the number of configurations that are sampled during tuning phases by only testing configurations that are expected to perform well. To predict which configurations might be optimal, the results from previous tuning iterations are used to extrapolate performance in the current tuning phase. The strategy allows to specify the degree of accuracy, i.e. how many \texttt{full-search} tuning phases are required before the extrapolation takes place. Predictive tuning is typically used with the \texttt{slow-config-filter}, which blocks configurations that show extremely poor performance from all successive tuning phases. \cite{Pelloth2020}
\end{description}


